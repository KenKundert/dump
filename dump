#!/usr/bin/env python3
"""Backup files to a remote server

Usage:
    dump [options] backup [full | incremental]
    dump [options] manifest
    dump [options] restore <filelist>...
    dump [options] cleanup

Options:
    -d <date>, --date <date>  date or time interval
    -n, --narrate             send duplicity narration to stdout
    -t, --trial-run           trial run
    -v, --verbose             verbose

If needed, date is given in one of the following forms:
1. now (current time - the default)
2. 3D12h (interval constructed using s, m, h, D, W, M, or Y)
3. YYYY/MM/DD, YYYY-MM-DD, MM/DD/YYYY, or MM-DD-YYYY (date)
"""

# Imports {{{1
from scripts import (
    abspath, cwd, fopen, exists, head, isexecutable, join, mkdir, rm, Run,
    script_prefs, ScriptError, sh, tail
)
from docopt import docopt
from textwrap import dedent
import socket
import getpass
import sys
import os

# Settings {{{1
name = 'ken'                                    # descriptive name for the backups
AbraxasGpgAccount = 'duplicity-kundert'         # abraxas account that holds passphrase for GPG encryption key
GpgPassphrase = None                            # passphrase for GPG encryption key (if specified, abraxas is not used)
SshIdentity = "~/.ssh/dumper"                   # ssh identify file (private key without passphrase)
DestServer = "dumper"                           # remote user and host (user@server)
DestDir = "/mnt/mnt1/{hostname}/{hostname}"     # remote directory for backup sets
SrcDir = "~"                                    # absolute path to directory to be backed up
ArchiveDir = "archives"                         # directory of duplicity housekeeping files
RestoreDir = 'restored'                         # directory that will hold restored files
LogFile = 'duplicity.log'
Excludes = [
    "~/tmp",
    "~/media",
    "~/effsim",
    "~/packages",
    "~/lib/locatedbs",
    "~/.downloads",
    "~/.local",
    "~/.mozilla",
    "~/.thunderbird",
    "~/.npm",
    "~/.wine",
    "~/.wine-x86_64",
    "~/.adobe",
    "~/.cache",
    "~/.config/mutt/cache",
    "~/.config/gconf",
    "~/.config/google-chrome*",
    "~/.config/pulse",
    "~/.config/Skype",
    "~/.dbus",
    "~/.gimp-*",
    "~/.gnome",
    "~/.gnome2",
    "~/.jitsi",
    "~/.purple",
    "~/.thumbnails",
    "~/.config/libreoffice",
    "~/.config/fish/generated_completions",
    "~/.local",
    "~/**/.hg",
    "~/**/.git",
    "~/**/tags",
    "~/**/*.pyc",
    "~/**/.*.arc",
    "~/**/*.ahdlcmi",
    "~/**/.*.swp",
    "{installDir}/{ArchiveDir}",
    "{installDir}/{LogFile}",
]

# commands to be run before and after backups
RunBeforeBackups = [
    "./clean-home >& clean.log",
        # remove the detritus before backing up
]
RunAfterBackups = [
    "./since-last-backup -u",
        # update the time of last successful backup in ~/.lastbackup
]

# if set, this file must exist or backups will quit with an error
MustExist = "$HOME/src/verif/av"

BwLimit = '2000'                                 # bandwidth limit in kb/s
Notify = "admin@shalmirane.com"                  # email address to notify when things go wrong
Notifier = 'notify-send -u normal Dump "{msg}"'  # notifier program
Lockfile = "{SrcDir}/.backups-are-running"       # lock file, used to tell if the program is already running


# Utility functions -- should not need to change anything below line {{{1
# Configure expand() so it expands ~, $var, and {attr} as expected
script_prefs(exit_upon_error=False, expanduser=True, expandvars=True)
hostname = socket.gethostname().split('.')[0]
user = getpass.getuser()
sshIdentity = join(SshIdentity)
installDir = abspath(head(__file__))
variables = locals()

# expand {attr} constructs in a string recursively, then expand ~ and $VAR
def expand(name):
    new = name.format(**variables)
    if new == name:
        return join(new) # join() is used to expand ~ and $VAR
    else:
        return expand(new)

# expand ~, $var, and {attr} constructs in a list of strings
def expandAll(names):
    return [expand(each) for each in names if each]

# take a list and double its length by adding a constant before each member
def prefix(constant, members):
    for member in members:
        yield constant
        yield member

# handle errors
def error(msg):
    if Notify:
        sh(['mail', '-s "dump: %s"' % msg, Notify],
            stdin=dedent('''
                source = {hostname}:{SrcDir}
                destination = {DestServer}:{DestDir}
            '''.format(**variables))
        )
    if Notifier:
        sh(Notifier.format(msg=msg))
    sys.exit(fail('dump: ' + msg))

# runDuplicity() {{{1
def runDuplicity(name, cmd, narrate):
    try:
        duplicity = Run(cmd, 's%sW' % ('oe' if narrate else 'OE'))
    except ScriptError as exception:
        print(str(exception))
        error('%s failed.' % name)

# backup() {{{1
def backup(level):
    if exists(lockfile):
        error("backups skipped because a previous run has not yet completed.")
    if MustExist and not exists(expand(MustExist)):
        error("%s: does not exist, perform proper setup and restart." % MustExist)
    try:
        for each in RunBeforeBackups:
            sh(expand(each))
        if lockfile:
            with fopen(lockfile, 'w') as f:
                print('PID = %s, wd = %s' % (pid, cwd()), file=f)
        cmd = (
            [   'duplicity',
                level,
                '--timeout', '1800',
                '--allow-source-mismatch',
            ]
          + expandAll(duplicityOptions)
          + expandAll(archiveDirCommand)
          + expandAll(sftpCommand)
          + list(prefix('--exclude', expandAll(Excludes)))
          + [srcDir, destination]
        )
        runDuplicity('backup', cmd, narrate)
        for each in RunAfterBackups:
            sh(expand(each))
    except KeyboardInterrupt:
        error('dump: killed at user request.')
    finally:
        if lockfile:
            rm(lockfile)

# restore() {{{1
def restore(filelist, date):
    date = ['--time', date] if date else []
    mkdir(join(restoreDir))
    for each in filelist:
        dest = join(restoreDir, tail(each))
        cmd = (
            [   'duplicity',
                'restore',
                '--file-to-restore', each,
                '--timeout', '120',
            ]
          + expandAll(duplicityOptions)
          + expandAll(archiveDirCommand)
          + expandAll(sftpCommand)
          + date
          + [destination, dest]
        )
        runDuplicity('restore', cmd, narrate)
        print("%s: restored as: %s" % (each, dest))

# manifest() {{{1
def manifest(date):
    date = ['--time', date] if date else []
    cmd = (
        [   'duplicity',
            'list-current-files',
            '--timeout', '600',
        ]
      + expandAll(duplicityOptions)
      + expandAll(archiveDirCommand)
      + expandAll(sftpCommand)
      + date
      + [destination]
    )
    runDuplicity('manifest', cmd, True)

# cleanup() {{{1
def cleanup(date):
    # first remove any extraneous files from failed sessions
    cmd = (
        [   'duplicity',
            'cleanup',
            '--force',
            '--timeout', '120',
        ]
      + expandAll(duplicityOptions)
      + expandAll(archiveDirCommand)
      + expandAll(sftpCommand)
      + [destination]
    )
    runDuplicity('cleanup', cmd, narrate)

    # now remove backup sets that only contain old files
    if date:
        cmd = ([
            'duplicity',
            'remove-older-than', date,
            '--force',
            '--timeout', '120',
        ] + expandAll(duplicityOptions)
          + expandAll(archiveDirCommand)
          + expandAll(sftpCommand)
          + [destination]
        )
        runDuplicity('remove', cmd, narrate)

# Setup {{{1
# Color messages {{{2
try:
    from textcolors import Colors, isTTY
    colors = Colors(isTTY())
    fail = colors.colorizer('red')
except ImportError:
    fail = lambda a: a

# Process the settings {{{2
try:
    destDir = expand(DestDir)
    srcDir = expand(SrcDir)
    archiveDir = expand(ArchiveDir)
    restoreDir = expand(RestoreDir)
    logFile = expand(LogFile)
    lockfile = expand(Lockfile) if Lockfile else None
    pid = os.getpid()

    # Duplicity and SSH options {{{2
    logFileArg = ['--log-file', logFile] if logFile else []
    bwLimitArg = '-l %s' % BwLimit if BwLimit else ''
    sshIdentityArg = '-i %s' % sshIdentity if sshIdentity else ''
    duplicityOptions = ['--ssh-backend', 'pexpect'] + logFileArg
    sftpCommand = ['--sftp-command', 'sftp {sshIdentityArg} {bwLimitArg}']
    archiveDirCommand = ['--archive-dir', archiveDir, '--name', name]
    destination = expand('sftp://{DestServer}/{destDir}')

    # Read command line {{{2
    cmdline = docopt(__doc__)
    duplicityOptions += ['-v9'] if cmdline['--verbose'] else ['-v8']
    duplicityOptions += ['--dry-run'] if cmdline['--trial-run'] else []
    narrate = cmdline['--narrate']

    # Get GPG passphrase {{{2
    if not GpgPassphrase:
        try:
            from abraxas import PasswordGenerator
        except ImportError:
            error('abraxas is not available, you must specify passphrase in dump settings.')
        pw = PasswordGenerator()
        pw.read_accounts()
        acct = pw.get_account(AbraxasGpgAccount)
        GpgPassphrase = pw.generate_password()
    os.environ['PASSPHRASE'] = GpgPassphrase

    # Run commands {{{1
    if cmdline['backup']:
        backup('full' if cmdline['full'] else 'incremental')
    elif cmdline['restore']:
        restore(cmdline['<filelist>'], cmdline['--date'])
    elif cmdline['manifest']:
        manifest(cmdline['--date'])
    elif cmdline['cleanup']:
        cleanup(cmdline['--date'])
    sys.exit()

except ScriptError as exception:
    error(str(exception))
except KeyboardInterrupt:
    error('dump: killed at user request')
